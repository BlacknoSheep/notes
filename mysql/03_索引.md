# 索引

索引（index）是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。

| 优点                                                  | 缺点                 |
| ----------------------------------------------------- | -------------------- |
| 提高数据查询效率，降低 I/O 成本。                     | 索引需要占空间。     |
| 通过索引列对数据进行排序，降低排序成本，降低CPU消耗。 | 会降低更新表的速度。 |

# 索引结构

mysql 的索引是在存储引擎层实现的，不同存储引擎有不同的结构，主要包含以下几种：

| 索引结构              | 描述                                                         | InnoDB | MyISAM | Memory |
| --------------------- | ------------------------------------------------------------ | ------ | ------ | ------ |
| B+ Tree索引           | 最常见，大部分引擎都支持。                                   | √      | √      | √      |
| Hash索引              | 底层数据结构是哈希表。查询效率高。只能进行对等比较（=，in），不支持范围查询，无法利用索引进行排序。 | ×      | ×      | √      |
| R-Tree（空间索引）    | 是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型。   | ×      | √      | ×      |
| Full-text（全文索引） | 通过建立倒排索引，快速匹配文档。                             | >=5.6  | √      | ×      |

- 在 mysql 中，InnoDB 具有自适应 hash 功能，存储引擎会更具 B+Tree 索引在指定条件下自动构建 hash 索引。

为什么使用 B+Tree ？

- 相比二叉树，层数更少，搜索效率更高。
-  而B-Tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低；
- 相比 hash 索引，B+ tree 支持范围匹配和排序。

# 索引分类

1. 按字段分类

| 分类     | 含义                                   | 特点                     | 关键字   |
| -------- | -------------------------------------- | ------------------------ | -------- |
| 主键索引 | 针对表中主键创建的索引                 | 默认自动创建，只能有一个 | PRIMARY  |
| 唯一索引 | 索引值必须唯一，但允许空值             | 允许多个                 | UNIQUE   |
| 普通索引 | 建立在普通字段上的索引                 | 允许多个                 |          |
| 全文索引 | 查找文本中的关键字，而非比较索引中的值 | 允许多个                 | FULLTEXT |

2. 按存储形式分类

| 分类                        | 含义                                           | 特点               |
| --------------------------- | ---------------------------------------------- | ------------------ |
| 聚簇索引（clustered index） | 将数据与索引一起存储，叶子节点保存了行数据     | 必须有，且只有一个 |
| 二级索引（secondary index） | 将数据与索引分开存储，叶子节点保存的是主键信息 | 允许多个           |

InnoDB 中聚集索引的选取规则：

- 若存在主键，则主键索引就是聚簇索引。
- 若不存在主键，则使用第一个非空的唯一索引（UNIQUE）作为聚簇索引。
- 若没有主键也没有非空的唯一索引，则 InnoDB 会自动生成一个 row id 作为隐藏的聚簇索引。

# 索引语法

```mysql
# 创建索引
create [unique|fulltext] index index_name on table_name (index_col_name [asc|desc],...);

# 查看索引
show index from table_name;

# 删除索引
drop index index_name on table_name;
```

- 添加主键约束或唯一约束时会自动创建对应的索引。
- 联合索引叶节点中会保存表的部分列数据。若仅对这几列中的数据进行全表查询，则可以只遍历该联合索引的叶子节点，而不用扫描完整的表数据，此时通过 `explain` 命令输出的执行信息中 type 字段为 index。

# 索引使用原则

- 走索引树比全表扫描或遍历叶节点效率高。
- 遍历覆盖索引的叶节点比全表扫描效率高。

## 最左前缀法则

如果索引了多列（联合索引），要遵守最左前缀法则。最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。
如果跳跃某一列，索引将部分失效（后面的字段索引失效，可以查看 explain 的 key_len 字段）。

```mysql
CREATE INDEX idx_name_age_gender ON `user` (name, age, gender);

EXPLAIN SELECT * FROM `user` WHERE name = 'A1A'; # 走索引树
EXPLAIN SELECT * FROM `user` WHERE age = 20; # 不走索引树
EXPLAIN SELECT * FROM `user` WHERE gender = '男'; # 不走索引树
EXPLAIN SELECT * FROM `user` WHERE name = 'A1A' AND age = 18; # 走索引树
EXPLAIN SELECT * FROM `user` WHERE name = 'A1A' AND gender = '男'; # name走索引树，gender不走索引树
```

## 范围查询

联合索引中，出现范围查询（>,<,!=），范围查询字段右侧的索引失效。

```mysql
EXPLAIN SELECT * FROM `user` WHERE name = 'A1A' AND age > 18 AND gender='男'; # gender不走索引
```

使用 （>=,<=）不会失效。

```mysql
EXPLAIN SELECT * FROM `user` WHERE name = 'A1A' AND age >= 18 AND gender='男'; # 都走索引
```

## 索引列运算

在索引列上进行运算操作（四则运算、函数等），索引将失效。

```mysql
EXPLAIN SELECT * FROM `user` WHERE SUBSTR(name,1) = 'A'; # 索引失效
```

##  字符串不加引号

```mysql
# name是字符串类型，这里发生了隐式类型转换，索引失效
EXPLAIN SELECT * FROM `user` WHERE name = 2233;
```

## 模糊查询

如果是尾部模糊匹配或中间模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。

```mysql
EXPLAIN SELECT * FROM `user` WHERE name LIKE 'A%'; # 走索引树
EXPLAIN SELECT * FROM `user` WHERE name LIKE '%A'; # 不走索引树
```

## or 连接

若 or 前后有一个没索引，则都不走索引。

```mysql
EXPLAIN SELECT * FROM `user` WHERE name='A1A' or salary=1800;
```

## 数据分布影响

如果MySQL评估使用索引比全表更慢，则不使用索引。

## sql 提示

SQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。

- `use index`：推荐使用该索引，最终可能不使用该索引。
- `ignore index`：忽略该索引。
- `force index`：强制使用该索引

```mysql
EXPLAIN SELECT * FROM `user` USE INDEX(idx_name_age_salary) WHERE name = 'A1A';
```

## 覆盖索引

尽量使用覆盖索引（查询使用了索引，并且需要返回的列在该索引中已经全部能够找到，减少回表），减少使用`select *`。

## 前缀索引

当字段类型为字符串时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO，影响查询效率。此时可以只将字符串的一部分前缀建立索引，这样可以大大节约索引空间，从而提高索引效率。

```mysql
CREATE INDEX idx_name ON `user` (name(2)); # 使用前2个字符作为索引
```

前缀长度可以根据索引的选择性来决定，选择性指的是不重复的索引值和表中记录总数的比值。索引性越高则查询效率越高。唯一索引的选择性是1，性能最高。

## 单列索引与联合索引

如果查询包含多个字段，建议建立联合索引，避免回表。

# 索引设计原则

1. 针对于数据量较大，且查询比较频繁的表建立索引。
2. 针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。
3. 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，索引的效率越高。
4. 如果是字符串类型的字段，字段的长度较长，可以建立前缀索引。
5. 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。
6. 要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。
7. 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询。
